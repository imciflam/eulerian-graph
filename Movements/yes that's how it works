using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace Movements
{

    public class Graph<T>
    {
        public Dictionary<T, HashSet<T>> AdjacencyList { get; } = new Dictionary<T, HashSet<T>>();

        public Graph(IEnumerable<T> vertices, IEnumerable<Tuple<T, T>> edges)
        {
            foreach (var vertex in vertices)
            {
                AddVertex(vertex);
            }

            foreach (var edge in edges)
            {
                AddEdge(edge); 
            }
        }

        public void AddVertex(T vertex)
        {
            AdjacencyList[vertex] = new HashSet<T>();
        }

        public void AddEdge(Tuple<T, T> edge)
        {
            if (AdjacencyList.ContainsKey(edge.Item1) && AdjacencyList.ContainsKey(edge.Item2))
            {
                AdjacencyList[edge.Item1].Add(edge.Item2);//откуда и куда
            }
        }
    }

    class Program
    {
        /// <summary>
        /// Движение между отделениями
        /// </summary>
        class Movement
        {
            /// <summary>
            /// Отделение откуда
            /// </summary>
            public string From;
            /// <summary>
            /// Отделение куда
            /// </summary>
            public string To;
            /// <summary>
            /// Индекс перехода
            /// </summary>
            public int index;

            // Можно добавлять в класс вспомогательные члены
        }

        static void Main(string[] args)
        {
            try
            {

                string[] ff = System.IO.File.ReadAllLines(@"..\..\movements2.txt");
                List<int> x = new List<int>();
                List<int> y = new List<int>();
                for (int i = 0; i < ff.Length; i++)
                {
                    string[] ss = ff[i].Split(';');
                    x.Add(Convert.ToInt32(ss[0]));
                    y.Add(Convert.ToInt32(ss[1]));
                }
                List<int> z = x.Concat(y).Distinct().ToList(); 
                int[] vertices = z.ToArray();

                var edges = new Tuple<int, int>[ff.Length];
                for (int i = 0; i < ff.Length; i++)
                {
                    string[] ss = ff[i].Split(';');
                    edges[i] = Tuple.Create(Convert.ToInt32(ss[0]), Convert.ToInt32(ss[1]));
                }

                var graph = new Graph<int>(vertices, edges);


                //Movement[] ms = new Movement[]
                //{
                //    new Movement() { From = "334", To = "331", index = 0 },
                //    new Movement() { From = "331", To = "334", index = 1 },
                //    new Movement() { From = "332", To = "331", index = 2 },
                //    //new Movement() { From = "125", To = "112", index = 4 }
                //};
                //string begin = "332";

               // string[] ff = System.IO.File.ReadAllLines(@"..\..\movements2.txt");
                Movement[] ms = new Movement[ff.Length];
                for (int i = 0; i < ff.Length; i++)
                {
                    string[] ss = ff[i].Split(';');
                    ms[i] = new Movement() { From = ss[0], To = ss[1], index = i };
                }
                string begin = ms[0].From;


                // поиск вариантов переходов
                Stopwatch start = Stopwatch.StartNew();
                List<int[]> result = FindMovements(begin, ms);
                start.Stop();
                Console.WriteLine(start); 

                // печать результатов
                PrintResults(ms, begin, result);

                Console.WriteLine("\nГотово!");
                Console.ReadKey();
            }
            catch (Exception exp)
            {
                Console.WriteLine(exp.ToString());
            }
        }

        /// <summary>
        /// Печать результатов
        /// </summary>
        /// <param name="ms">Движения между отделениями</param>
        /// <param name="begin">Первое отделение (откуда старт)</param>
        /// <param name="result">Результат выполнения функции FindMovements()</param>
        static void PrintResults(Movement[] ms, string begin, List<int[]> result)
        {
            Console.WriteLine(result.Count);
            //return;


            if (result == null || result.Count == 0)
            {
                Console.WriteLine("Переходов не найдено.");
            }
            else
            {
                Console.WriteLine("Найденные переходы:");

                foreach (int[] list in result)
                {
                    Movement prev = null;
                    for (int i = 0; i < ms.Length; i++)
                    {
                        if (i >= list.Length)
                        {
                            Console.Write("Ошибка: отсутствует переход.");
                        }
                        else
                        {
                            int idx = list[i];
                            if (idx < 0 || idx >= ms.Length)
                            {
                                Console.Write("Ошибка: индекс за пределами диапазона.");
                            }
                            else
                            {
                                Movement movement = ms[idx];

                                string b = prev == null ? begin : prev.To;
                                
                                if (movement.From != b)
                                {
                                    Console.Write(" ОШИБКА!");
                                }
                                prev = movement;
                            }
                        }
                    }
                    if (list.Length > ms.Length)
                    {
                        Console.WriteLine("Ошибка: имеются лишние переходы.");
                    }

                    //Console.WriteLine();
                }
            }
        }

        /// <summary>
        /// Поиск всех вариантов движения, начиная с указанного отделения.
        /// </summary>
        /// <param name="firstDivision">Первое отделение (откуда старт)</param>
        /// <param name="ms">Движения между отделениями</param>
        /// <returns>Результат в виде списка индексов переходов между отделениями в исходном массиве</returns>
        static List<int[]> FindMovements(string firstDivision, Movement[] ms)
        {
            string from = firstDivision;//начало обхода
            List<int[]> paths = new List<int[]>();//лист массивов проходов
            var currentPath = new List<int>();//саблист текущего обхода
            InspectPath(from, currentPath, ms, ref paths); 
            return paths;
        }
        static void InspectPath(string from, List<int> currentPath, Movement[] ms, ref List<int[]> paths)
        {
            List<Movement> to = new List<Movement>(); 
            
            foreach (var m in ms)
            {
                if (from == m.From && !currentPath.Contains(m.index))
                {
                    to.Add(m);//список смежности для текущей ноды без повторов проходов предыдущей
                }
            }  
            if (to.Count == 0)//в список смежности больше нечего добавить, все переходы использованы
            {
                if (currentPath.Count == ms.Length)//если длина 30
                {
                    paths.Add(currentPath.ToArray());//добавить в лист проходов
                }
                else
                {
                    return;//вернуться для отката на момент, когда переходы есть
                }
            }
            else
            {
                foreach (var next in to)
                {
                    currentPath.Add(next.index);//добавить элемент в текущий лист
                    InspectPath(next.To, currentPath, ms, ref paths);//рекурсия - для элемента из списка смежности заново запуск
                    currentPath.Remove(next.index);//откат на момент, когда переходы есть 
                } 
                return;
            }
        }
    }
}
